const pTF=require("./promise-timeout"),pCF=require("./promise-catch-function"),pCCF=require("./promise-chunk-catch-function"),promiseChunkGenerator=async function*({promiseExecutors:e,concurrency:r,perChunkTimeoutDuration:o,perPromiseTimeoutDuration:t,promiseTimeoutFunction:i,promiseCatchFunction:u,returnRejectedPromiseExecutor:c,promiseChunkCatchFunction:n}){e=e||[],r=r||1,o=o||3e5,t=t||12e4,i=i||pTF,u=u||pCF,n=n||pCCF,c=c||!0;const m=e.length;for(let s=0;s<m;s+=r){let p=[];for(let o=0;o<r;o++)if(s+o<m){let r=i({promise:new Promise(e[s+o]),timeoutDuration:t});r.__executor=e[s+o],p.push(r)}const a=e=>e.map(e=>e.catch(r=>u({error:r,returnRejectedPromiseExecutor:c,promise:e})));let h=Promise.all(a(p));h.__executors=p.map(e=>e.__executor);const C=e=>r=>n({error:r,returnRejectedPromiseExecutor:c,promise:e});yield await i({promise:h,timeoutDuration:o}).catch(C(h))}};module.exports=promiseChunkGenerator;